// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.31.0
// source: protos/assets/assets.proto

const { BinaryReader, BinaryWriter } = require("@bufbuild/protobuf/wire");
const { Timestamp } = require("../../google/protobuf/timestamp");
const { UuidAndUsername } = require("../common");

const protobufPackage = "assets";

const MinecraftIdentity_Type = {
  TYPE_UNSPECIFIED: 0,
  TYPE_MOJANG: 1,
  TYPE_MICROSOFT: 2,
  UNRECOGNIZED: -1,
};

function minecraftIdentity_TypeFromJSON(object) {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return MinecraftIdentity_Type.TYPE_UNSPECIFIED;
    case 1:
    case "TYPE_MOJANG":
      return MinecraftIdentity_Type.TYPE_MOJANG;
    case 2:
    case "TYPE_MICROSOFT":
      return MinecraftIdentity_Type.TYPE_MICROSOFT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MinecraftIdentity_Type.UNRECOGNIZED;
  }
}

function minecraftIdentity_TypeToJSON(object) {
  switch (object) {
    case MinecraftIdentity_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case MinecraftIdentity_Type.TYPE_MOJANG:
      return "TYPE_MOJANG";
    case MinecraftIdentity_Type.TYPE_MICROSOFT:
      return "TYPE_MICROSOFT";
    case MinecraftIdentity_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

const LauncherHandshake_ElectronBinariesType = {
  ELECTRON_BINARIES_TYPE_UNSPECIFIED: 0,
  ELECTRON_BINARIES_TYPE_OVERWOLF_OW_ELECTRON: 1,
  ELECTRON_BINARIES_TYPE_ELECTRON: 2,
  UNRECOGNIZED: -1,
};

function launcherHandshake_ElectronBinariesTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "ELECTRON_BINARIES_TYPE_UNSPECIFIED":
      return LauncherHandshake_ElectronBinariesType.ELECTRON_BINARIES_TYPE_UNSPECIFIED;
    case 1:
    case "ELECTRON_BINARIES_TYPE_OVERWOLF_OW_ELECTRON":
      return LauncherHandshake_ElectronBinariesType.ELECTRON_BINARIES_TYPE_OVERWOLF_OW_ELECTRON;
    case 2:
    case "ELECTRON_BINARIES_TYPE_ELECTRON":
      return LauncherHandshake_ElectronBinariesType.ELECTRON_BINARIES_TYPE_ELECTRON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LauncherHandshake_ElectronBinariesType.UNRECOGNIZED;
  }
}

function launcherHandshake_ElectronBinariesTypeToJSON(object) {
  switch (object) {
    case LauncherHandshake_ElectronBinariesType.ELECTRON_BINARIES_TYPE_UNSPECIFIED:
      return "ELECTRON_BINARIES_TYPE_UNSPECIFIED";
    case LauncherHandshake_ElectronBinariesType.ELECTRON_BINARIES_TYPE_OVERWOLF_OW_ELECTRON:
      return "ELECTRON_BINARIES_TYPE_OVERWOLF_OW_ELECTRON";
    case LauncherHandshake_ElectronBinariesType.ELECTRON_BINARIES_TYPE_ELECTRON:
      return "ELECTRON_BINARIES_TYPE_ELECTRON";
    case LauncherHandshake_ElectronBinariesType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseMinecraftIdentity() {
  return { player: undefined, type: 0, authenticatorJwt: "" };
}

const MinecraftIdentity = {
  encode(message, writer = new BinaryWriter()) {
    if (message.player !== undefined) {
      UuidAndUsername.encode(message.player, writer.uint32(10).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.authenticatorJwt !== "") {
      writer.uint32(26).string(message.authenticatorJwt);
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinecraftIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.player = UuidAndUsername.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authenticatorJwt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return {
      player: isSet(object.player) ? UuidAndUsername.fromJSON(object.player) : undefined,
      type: isSet(object.type) ? minecraftIdentity_TypeFromJSON(object.type) : 0,
      authenticatorJwt: isSet(object.authenticatorJwt) ? String(object.authenticatorJwt) : "",
    };
  },

  toJSON(message) {
    const obj = {};
    if (message.player !== undefined) {
      obj.player = UuidAndUsername.toJSON(message.player);
    }
    if (message.type !== 0) {
      obj.type = minecraftIdentity_TypeToJSON(message.type);
    }
    if (message.authenticatorJwt !== "") {
      obj.authenticatorJwt = message.authenticatorJwt;
    }
    return obj;
  },

  create(base) {
    return MinecraftIdentity.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseMinecraftIdentity();
    message.player = (object.player !== undefined && object.player !== null)
      ? UuidAndUsername.fromPartial(object.player)
      : undefined;
    message.type = object.type ?? 0;
    message.authenticatorJwt = object.authenticatorJwt ?? "";
    return message;
  },
};

function createBaseLauncherHandshake() {
  return {
    environment: "",
    sessionId: "",
    updaterStream: "",
    electronBinariesType: 0,
    elevated: false,
    silentStart: false,
    uptimeSinceStart: 0,
    startedAt: undefined,
    buildNumber: 0,
    gitCommitHash: "",
    gitShortCommitHash: "",
    optimizedAds: false,
    analytics: false,
    owahe: false,
  };
}

const LauncherHandshake = {
  encode(message, writer = new BinaryWriter()) {
    if (message.environment !== "") {
      writer.uint32(10).string(message.environment);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.updaterStream !== "") {
      writer.uint32(26).string(message.updaterStream);
    }
    if (message.electronBinariesType !== 0) {
      writer.uint32(32).int32(message.electronBinariesType);
    }
    if (message.elevated !== false) {
      writer.uint32(40).bool(message.elevated);
    }
    if (message.silentStart !== false) {
      writer.uint32(48).bool(message.silentStart);
    }
    if (message.uptimeSinceStart !== 0) {
      writer.uint32(56).int32(message.uptimeSinceStart);
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(66).fork()).join();
    }
    if (message.buildNumber !== 0) {
      writer.uint32(72).int32(message.buildNumber);
    }
    if (message.gitCommitHash !== "") {
      writer.uint32(82).string(message.gitCommitHash);
    }
    if (message.gitShortCommitHash !== "") {
      writer.uint32(90).string(message.gitShortCommitHash);
    }
    if (message.optimizedAds !== false) {
      writer.uint32(104).bool(message.optimizedAds);
    }
    if (message.analytics !== false) {
      writer.uint32(112).bool(message.analytics);
    }
    if (message.owahe !== false) {
      writer.uint32(120).bool(message.owahe);
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLauncherHandshake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updaterStream = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.electronBinariesType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.elevated = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.silentStart = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uptimeSinceStart = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.buildNumber = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.gitCommitHash = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.gitShortCommitHash = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.optimizedAds = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.analytics = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.owahe = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return {
      environment: isSet(object.environment) ? String(object.environment) : "",
      sessionId: isSet(object.sessionId) ? String(object.sessionId) : "",
      updaterStream: isSet(object.updaterStream) ? String(object.updaterStream) : "",
      electronBinariesType: isSet(object.electronBinariesType)
        ? launcherHandshake_ElectronBinariesTypeFromJSON(object.electronBinariesType)
        : 0,
      elevated: isSet(object.elevated) ? Boolean(object.elevated) : false,
      silentStart: isSet(object.silentStart) ? Boolean(object.silentStart) : false,
      uptimeSinceStart: isSet(object.uptimeSinceStart) ? Number(object.uptimeSinceStart) : 0,
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
      buildNumber: isSet(object.buildNumber) ? Number(object.buildNumber) : 0,
      gitCommitHash: isSet(object.gitCommitHash) ? String(object.gitCommitHash) : "",
      gitShortCommitHash: isSet(object.gitShortCommitHash) ? String(object.gitShortCommitHash) : "",
      optimizedAds: isSet(object.optimizedAds) ? Boolean(object.optimizedAds) : false,
      analytics: isSet(object.analytics) ? Boolean(object.analytics) : false,
      owahe: isSet(object.owahe) ? Boolean(object.owahe) : false,
    };
  },

  toJSON(message) {
    const obj = {};
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.updaterStream !== "") {
      obj.updaterStream = message.updaterStream;
    }
    if (message.electronBinariesType !== 0) {
      obj.electronBinariesType = launcherHandshake_ElectronBinariesTypeToJSON(message.electronBinariesType);
    }
    if (message.elevated !== false) {
      obj.elevated = message.elevated;
    }
    if (message.silentStart !== false) {
      obj.silentStart = message.silentStart;
    }
    if (message.uptimeSinceStart !== 0) {
      obj.uptimeSinceStart = Math.round(message.uptimeSinceStart);
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.buildNumber !== 0) {
      obj.buildNumber = Math.round(message.buildNumber);
    }
    if (message.gitCommitHash !== "") {
      obj.gitCommitHash = message.gitCommitHash;
    }
    if (message.gitShortCommitHash !== "") {
      obj.gitShortCommitHash = message.gitShortCommitHash;
    }
    if (message.optimizedAds !== false) {
      obj.optimizedAds = message.optimizedAds;
    }
    if (message.analytics !== false) {
      obj.analytics = message.analytics;
    }
    if (message.owahe !== false) {
      obj.owahe = message.owahe;
    }
    return obj;
  },

  create(base) {
    return LauncherHandshake.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseLauncherHandshake();
    message.environment = object.environment ?? "";
    message.sessionId = object.sessionId ?? "";
    message.updaterStream = object.updaterStream ?? "";
    message.electronBinariesType = object.electronBinariesType ?? 0;
    message.elevated = object.elevated ?? false;
    message.silentStart = object.silentStart ?? false;
    message.uptimeSinceStart = object.uptimeSinceStart ?? 0;
    message.startedAt = object.startedAt ?? undefined;
    message.buildNumber = object.buildNumber ?? 0;
    message.gitCommitHash = object.gitCommitHash ?? "";
    message.gitShortCommitHash = object.gitShortCommitHash ?? "";
    message.optimizedAds = object.optimizedAds ?? false;
    message.analytics = object.analytics ?? false;
    message.owahe = object.owahe ?? false;
    return message;
  },
};

function createBaseLauncherVersion() {
  return { semver: "" };
}

const LauncherVersion = {
  encode(message, writer = new BinaryWriter()) {
    if (message.semver !== "") {
      writer.uint32(10).string(message.semver);
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLauncherVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.semver = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return { semver: isSet(object.semver) ? String(object.semver) : "" };
  },

  toJSON(message) {
    const obj = {};
    if (message.semver !== "") {
      obj.semver = message.semver;
    }
    return obj;
  },

  create(base) {
    return LauncherVersion.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseLauncherVersion();
    message.semver = object.semver ?? "";
    return message;
  },
};

function createBaseHandshake() {
  return {
    identity: undefined,
    launcherVersion: undefined,
    installationId: "",
    hwid: "",
    operatingSystem: "",
    cpuArchitecture: "",
    launcherHandshake: undefined,
    canaryToken: "",
    operatingSystemRelease: "",
  };
}

const Handshake = {
  encode(message, writer = new BinaryWriter()) {
    if (message.identity !== undefined) {
      MinecraftIdentity.encode(message.identity, writer.uint32(10).fork()).join();
    }
    if (message.launcherVersion !== undefined) {
      LauncherVersion.encode(message.launcherVersion, writer.uint32(18).fork()).join();
    }
    if (message.installationId !== "") {
      writer.uint32(26).string(message.installationId);
    }
    if (message.hwid !== "") {
      writer.uint32(34).string(message.hwid);
    }
    if (message.operatingSystem !== "") {
      writer.uint32(42).string(message.operatingSystem);
    }
    if (message.cpuArchitecture !== "") {
      writer.uint32(50).string(message.cpuArchitecture);
    }
    if (message.launcherHandshake !== undefined) {
      LauncherHandshake.encode(message.launcherHandshake, writer.uint32(74).fork()).join();
    }
    if (message.canaryToken !== "") {
      writer.uint32(82).string(message.canaryToken);
    }
    if (message.operatingSystemRelease !== "") {
      writer.uint32(90).string(message.operatingSystemRelease);
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandshake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identity = MinecraftIdentity.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.launcherVersion = LauncherVersion.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.installationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hwid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.operatingSystem = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cpuArchitecture = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.launcherHandshake = LauncherHandshake.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.canaryToken = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.operatingSystemRelease = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return {
      identity: isSet(object.identity) ? MinecraftIdentity.fromJSON(object.identity) : undefined,
      launcherVersion: isSet(object.launcherVersion) ? LauncherVersion.fromJSON(object.launcherVersion) : undefined,
      installationId: isSet(object.installationId) ? String(object.installationId) : "",
      hwid: isSet(object.hwid) ? String(object.hwid) : "",
      operatingSystem: isSet(object.operatingSystem) ? String(object.operatingSystem) : "",
      cpuArchitecture: isSet(object.cpuArchitecture) ? String(object.cpuArchitecture) : "",
      launcherHandshake: isSet(object.launcherHandshake)
        ? LauncherHandshake.fromJSON(object.launcherHandshake)
        : undefined,
      canaryToken: isSet(object.canaryToken) ? String(object.canaryToken) : "",
      operatingSystemRelease: isSet(object.operatingSystemRelease)
        ? String(object.operatingSystemRelease)
        : "",
    };
  },

  toJSON(message) {
    const obj = {};
    if (message.identity !== undefined) {
      obj.identity = MinecraftIdentity.toJSON(message.identity);
    }
    if (message.launcherVersion !== undefined) {
      obj.launcherVersion = LauncherVersion.toJSON(message.launcherVersion);
    }
    if (message.installationId !== "") {
      obj.installationId = message.installationId;
    }
    if (message.hwid !== "") {
      obj.hwid = message.hwid;
    }
    if (message.operatingSystem !== "") {
      obj.operatingSystem = message.operatingSystem;
    }
    if (message.cpuArchitecture !== "") {
      obj.cpuArchitecture = message.cpuArchitecture;
    }
    if (message.launcherHandshake !== undefined) {
      obj.launcherHandshake = LauncherHandshake.toJSON(message.launcherHandshake);
    }
    if (message.canaryToken !== "") {
      obj.canaryToken = message.canaryToken;
    }
    if (message.operatingSystemRelease !== "") {
      obj.operatingSystemRelease = message.operatingSystemRelease;
    }
    return obj;
  },

  create(base) {
    return Handshake.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseHandshake();
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? MinecraftIdentity.fromPartial(object.identity)
      : undefined;
    message.launcherVersion = (object.launcherVersion !== undefined && object.launcherVersion !== null)
      ? LauncherVersion.fromPartial(object.launcherVersion)
      : undefined;
    message.installationId = object.installationId ?? "";
    message.hwid = object.hwid ?? "";
    message.operatingSystem = object.operatingSystem ?? "";
    message.cpuArchitecture = object.cpuArchitecture ?? "";
    message.launcherHandshake = (object.launcherHandshake !== undefined && object.launcherHandshake !== null)
      ? LauncherHandshake.fromPartial(object.launcherHandshake)
      : undefined;
    message.canaryToken = object.canaryToken ?? "";
    message.operatingSystemRelease = object.operatingSystemRelease ?? "";
    return message;
  },
};

function toTimestamp(date) {
  const seconds = BigInt(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t) {
  let millis = (Number(t.seconds.toString()) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new Date(millis);
}

function fromJsonTimestamp(o) {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value) {
  return value !== null && value !== undefined;
}

// Export all the necessary components
module.exports = {
  protobufPackage,
  MinecraftIdentity_Type,
  minecraftIdentity_TypeFromJSON,
  minecraftIdentity_TypeToJSON,
  LauncherHandshake_ElectronBinariesType,
  launcherHandshake_ElectronBinariesTypeFromJSON,
  launcherHandshake_ElectronBinariesTypeToJSON,
  MinecraftIdentity,
  LauncherHandshake,
  LauncherVersion,
  Handshake,
  toTimestamp,
  fromTimestamp,
  fromJsonTimestamp,
  isSet
};