// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.31.0
// source: protos/assets/emotes.proto

/* eslint-disable */
const { BinaryReader, BinaryWriter } = require("@bufbuild/protobuf/wire");
const { Timestamp } = require("../../google/protobuf/timestamp");

const protobufPackage = "assets";

/** Status enum for UseEmoteResponse */
const UseEmoteResponseStatus = {
  STATUS_UNSPECIFIED: 0,
  STATUS_OK: 1,
  STATUS_EMOTE_NOT_OWNED: 2,
  UNRECOGNIZED: -1,
};

function useEmoteResponseStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return UseEmoteResponseStatus.STATUS_UNSPECIFIED;
    case 1:
    case "STATUS_OK":
      return UseEmoteResponseStatus.STATUS_OK;
    case 2:
    case "STATUS_EMOTE_NOT_OWNED":
      return UseEmoteResponseStatus.STATUS_EMOTE_NOT_OWNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UseEmoteResponseStatus.UNRECOGNIZED;
  }
}

function useEmoteResponseStatusToJSON(object) {
  switch (object) {
    case UseEmoteResponseStatus.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case UseEmoteResponseStatus.STATUS_OK:
      return "STATUS_OK";
    case UseEmoteResponseStatus.STATUS_EMOTE_NOT_OWNED:
      return "STATUS_EMOTE_NOT_OWNED";
    case UseEmoteResponseStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseLoginRequest() {
  return {};
}

const LoginRequest = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_) {
    return {};
  },

  toJSON(_) {
    const obj = {};
    return obj;
  },

  create(base) {
    return LoginRequest.fromPartial(base ?? {});
  },

  fromPartial(_) {
    const message = createBaseLoginRequest();
    return message;
  },
};

function createBaseLoginResponse() {
  return { 
    ownedEmoteIds: [], 
    equippedEmoteIds: [], 
    lunarPlusFreeEmoteId: 0, 
    ownedEmotes: [], 
    hasAllEmotesFlag: false 
  };
}

const LoginResponse = {
  encode(message, writer = new BinaryWriter()) {
    writer.uint32(10).fork();
    for (const v of message.ownedEmoteIds) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.equippedEmoteIds) {
      writer.int32(v);
    }
    writer.join();
    if (message.lunarPlusFreeEmoteId !== 0) {
      writer.uint32(24).int32(message.lunarPlusFreeEmoteId);
    }
    for (const v of message.ownedEmotes) {
      OwnedEmote.encode(v, writer.uint32(58).fork()).join();
    }
    if (message.hasAllEmotesFlag !== false) {
      writer.uint32(40).bool(message.hasAllEmotesFlag);
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.ownedEmoteIds.push(reader.int32());
            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ownedEmoteIds.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 2: {
          if (tag === 16) {
            message.equippedEmoteIds.push(reader.int32());
            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.equippedEmoteIds.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.lunarPlusFreeEmoteId = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.ownedEmotes.push(OwnedEmote.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.hasAllEmotesFlag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return {
      ownedEmoteIds: globalThis.Array.isArray(object?.ownedEmoteIds)
        ? object.ownedEmoteIds.map((e) => globalThis.Number(e))
        : [],
      equippedEmoteIds: globalThis.Array.isArray(object?.equippedEmoteIds)
        ? object.equippedEmoteIds.map((e) => globalThis.Number(e))
        : [],
      lunarPlusFreeEmoteId: isSet(object.lunarPlusFreeEmoteId) ? globalThis.Number(object.lunarPlusFreeEmoteId) : 0,
      ownedEmotes: globalThis.Array.isArray(object?.ownedEmotes)
        ? object.ownedEmotes.map((e) => OwnedEmote.fromJSON(e))
        : [],
      hasAllEmotesFlag: isSet(object.hasAllEmotesFlag) ? globalThis.Boolean(object.hasAllEmotesFlag) : false,
    };
  },

  toJSON(message) {
    const obj = {};
    if (message.ownedEmoteIds?.length) {
      obj.ownedEmoteIds = message.ownedEmoteIds.map((e) => Math.round(e));
    }
    if (message.equippedEmoteIds?.length) {
      obj.equippedEmoteIds = message.equippedEmoteIds.map((e) => Math.round(e));
    }
    if (message.lunarPlusFreeEmoteId !== 0) {
      obj.lunarPlusFreeEmoteId = Math.round(message.lunarPlusFreeEmoteId);
    }
    if (message.ownedEmotes?.length) {
      obj.ownedEmotes = message.ownedEmotes.map((e) => OwnedEmote.toJSON(e));
    }
    if (message.hasAllEmotesFlag !== false) {
      obj.hasAllEmotesFlag = message.hasAllEmotesFlag;
    }
    return obj;
  },

  create(base) {
    return LoginResponse.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseLoginResponse();
    message.ownedEmoteIds = object.ownedEmoteIds?.map((e) => e) || [];
    message.equippedEmoteIds = object.equippedEmoteIds?.map((e) => e) || [];
    message.lunarPlusFreeEmoteId = object.lunarPlusFreeEmoteId ?? 0;
    message.ownedEmotes = object.ownedEmotes?.map((e) => OwnedEmote.fromPartial(e)) || [];
    message.hasAllEmotesFlag = object.hasAllEmotesFlag ?? false;
    return message;
  },
};

function createBaseOwnedEmote() {
  return { emoteId: 0, grantedAt: undefined, expiresAt: undefined };
}

const OwnedEmote = {
  encode(message, writer = new BinaryWriter()) {
    if (message.emoteId !== 0) {
      writer.uint32(8).int32(message.emoteId);
    }
    if (message.grantedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.grantedAt), writer.uint32(18).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOwnedEmote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.emoteId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.grantedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return {
      emoteId: isSet(object.emoteId) ? globalThis.Number(object.emoteId) : 0,
      grantedAt: isSet(object.grantedAt) ? fromJsonTimestamp(object.grantedAt) : undefined,
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
    };
  },

  toJSON(message) {
    const obj = {};
    if (message.emoteId !== 0) {
      obj.emoteId = Math.round(message.emoteId);
    }
    if (message.grantedAt !== undefined) {
      obj.grantedAt = message.grantedAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },

  create(base) {
    return OwnedEmote.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseOwnedEmote();
    message.emoteId = object.emoteId ?? 0;
    message.grantedAt = object.grantedAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function toTimestamp(date) {
  const seconds = BigInt(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t) {
  let millis = (globalThis.Number(t.seconds.toString()) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value) {
  return value !== null && value !== undefined;
}

// CommonJS exports
module.exports = {
  protobufPackage,
  UseEmoteResponseStatus,
  useEmoteResponseStatusFromJSON,
  useEmoteResponseStatusToJSON,
  LoginRequest,
  LoginResponse,
  OwnedEmote,
};