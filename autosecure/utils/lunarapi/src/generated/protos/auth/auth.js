// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.31.0
// source: protos/auth/auth.proto

/* eslint-disable */
const { BinaryReader, BinaryWriter } = require("@bufbuild/protobuf/wire");
const { UuidAndUsername } = require("../common");

const protobufPackage = "auth";

function createBaseServerboundWebSocketMessage() {
  return { hello: undefined, encryptionResponse: undefined, encryptionFail: undefined };
}

const ServerboundWebSocketMessage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.hello !== undefined) {
      HelloMessage.encode(message.hello, writer.uint32(10).fork()).join();
    }
    if (message.encryptionResponse !== undefined) {
      EncryptionResponseMessage.encode(message.encryptionResponse, writer.uint32(18).fork()).join();
    }
    if (message.encryptionFail !== undefined) {
      EncryptionFailMessage.encode(message.encryptionFail, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerboundWebSocketMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hello = HelloMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.encryptionResponse = EncryptionResponseMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.encryptionFail = EncryptionFailMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return {
      hello: isSet(object.hello) ? HelloMessage.fromJSON(object.hello) : undefined,
      encryptionResponse: isSet(object.encryptionResponse)
        ? EncryptionResponseMessage.fromJSON(object.encryptionResponse)
        : undefined,
      encryptionFail: isSet(object.encryptionFail) ? EncryptionFailMessage.fromJSON(object.encryptionFail) : undefined,
    };
  },

  toJSON(message) {
    const obj = {};
    if (message.hello !== undefined) {
      obj.hello = HelloMessage.toJSON(message.hello);
    }
    if (message.encryptionResponse !== undefined) {
      obj.encryptionResponse = EncryptionResponseMessage.toJSON(message.encryptionResponse);
    }
    if (message.encryptionFail !== undefined) {
      obj.encryptionFail = EncryptionFailMessage.toJSON(message.encryptionFail);
    }
    return obj;
  },

  create(base) {
    return ServerboundWebSocketMessage.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseServerboundWebSocketMessage();
    message.hello = (object.hello !== undefined && object.hello !== null)
      ? HelloMessage.fromPartial(object.hello)
      : undefined;
    message.encryptionResponse = (object.encryptionResponse !== undefined && object.encryptionResponse !== null)
      ? EncryptionResponseMessage.fromPartial(object.encryptionResponse)
      : undefined;
    message.encryptionFail = (object.encryptionFail !== undefined && object.encryptionFail !== null)
      ? EncryptionFailMessage.fromPartial(object.encryptionFail)
      : undefined;
    return message;
  },
};

function createBaseClientboundWebSocketMessage() {
  return { encryptionRequest: undefined, authSuccess: undefined };
}

const ClientboundWebSocketMessage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.encryptionRequest !== undefined) {
      EncryptionRequestMessage.encode(message.encryptionRequest, writer.uint32(10).fork()).join();
    }
    if (message.authSuccess !== undefined) {
      AuthSuccessMessage.encode(message.authSuccess, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientboundWebSocketMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.encryptionRequest = EncryptionRequestMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.authSuccess = AuthSuccessMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return {
      encryptionRequest: isSet(object.encryptionRequest)
        ? EncryptionRequestMessage.fromJSON(object.encryptionRequest)
        : undefined,
      authSuccess: isSet(object.authSuccess) ? AuthSuccessMessage.fromJSON(object.authSuccess) : undefined,
    };
  },

  toJSON(message) {
    const obj = {};
    if (message.encryptionRequest !== undefined) {
      obj.encryptionRequest = EncryptionRequestMessage.toJSON(message.encryptionRequest);
    }
    if (message.authSuccess !== undefined) {
      obj.authSuccess = AuthSuccessMessage.toJSON(message.authSuccess);
    }
    return obj;
  },

  create(base) {
    return ClientboundWebSocketMessage.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseClientboundWebSocketMessage();
    message.encryptionRequest = (object.encryptionRequest !== undefined && object.encryptionRequest !== null)
      ? EncryptionRequestMessage.fromPartial(object.encryptionRequest)
      : undefined;
    message.authSuccess = (object.authSuccess !== undefined && object.authSuccess !== null)
      ? AuthSuccessMessage.fromPartial(object.authSuccess)
      : undefined;
    return message;
  },
};

function createBaseHelloMessage() {
  return { identity: undefined };
}

const HelloMessage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.identity !== undefined) {
      UuidAndUsername.encode(message.identity, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHelloMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identity = UuidAndUsername.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return { identity: isSet(object.identity) ? UuidAndUsername.fromJSON(object.identity) : undefined };
  },

  toJSON(message) {
    const obj = {};
    if (message.identity !== undefined) {
      obj.identity = UuidAndUsername.toJSON(message.identity);
    }
    return obj;
  },

  create(base) {
    return HelloMessage.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseHelloMessage();
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? UuidAndUsername.fromPartial(object.identity)
      : undefined;
    return message;
  },
};

function createBaseEncryptionRequestMessage() {
  return { publicKey: new Uint8Array(0), randomBytes: new Uint8Array(0) };
}

const EncryptionRequestMessage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.publicKey.length !== 0) {
      writer.uint32(10).bytes(message.publicKey);
    }
    if (message.randomBytes.length !== 0) {
      writer.uint32(18).bytes(message.randomBytes);
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptionRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.randomBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return {
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      randomBytes: isSet(object.randomBytes) ? bytesFromBase64(object.randomBytes) : new Uint8Array(0),
    };
  },

  toJSON(message) {
    const obj = {};
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.randomBytes.length !== 0) {
      obj.randomBytes = base64FromBytes(message.randomBytes);
    }
    return obj;
  },

  create(base) {
    return EncryptionRequestMessage.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseEncryptionRequestMessage();
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.randomBytes = object.randomBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseEncryptionFailMessage() {
  return { reason: "" };
}

const EncryptionFailMessage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptionFailMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return { reason: isSet(object.reason) ? String(object.reason) : "" };
  },

  toJSON(message) {
    const obj = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base) {
    return EncryptionFailMessage.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseEncryptionFailMessage();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseEncryptionResponseMessage() {
  return { secretKey: new Uint8Array(0), publicKey: new Uint8Array(0) };
}

const EncryptionResponseMessage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.secretKey.length !== 0) {
      writer.uint32(10).bytes(message.secretKey);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(18).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptionResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secretKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return {
      secretKey: isSet(object.secretKey) ? bytesFromBase64(object.secretKey) : new Uint8Array(0),
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message) {
    const obj = {};
    if (message.secretKey.length !== 0) {
      obj.secretKey = base64FromBytes(message.secretKey);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(base) {
    return EncryptionResponseMessage.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseEncryptionResponseMessage();
    message.secretKey = object.secretKey ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAuthSuccessMessage() {
  return { jwt: "" };
}

const AuthSuccessMessage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.jwt !== "") {
      writer.uint32(10).string(message.jwt);
    }
    return writer;
  },

  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthSuccessMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jwt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object) {
    return { jwt: isSet(object.jwt) ? String(object.jwt) : "" };
  },

  toJSON(message) {
    const obj = {};
    if (message.jwt !== "") {
      obj.jwt = message.jwt;
    }
    return obj;
  },

  create(base) {
    return AuthSuccessMessage.fromPartial(base ?? {});
  },

  fromPartial(object) {
    const message = createBaseAuthSuccessMessage();
    message.jwt = object.jwt ?? "";
    return message;
  },
};

function bytesFromBase64(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

function isSet(value) {
  return value !== null && value !== undefined;
}

module.exports = {
  protobufPackage,
  ServerboundWebSocketMessage,
  ClientboundWebSocketMessage,
  HelloMessage,
  EncryptionRequestMessage,
  EncryptionFailMessage,
  EncryptionResponseMessage,
  AuthSuccessMessage,
};